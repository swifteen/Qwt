<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Qwt User&apos;s Guide: qwt_wheel.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>qwt_wheel.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/* -*- mode: C++ ; c-file-style: "stroustrup" -*- *****************************</span>
00002 <span class="comment"> * Qwt Widget Library</span>
00003 <span class="comment"> * Copyright (C) 1997   Josef Wilgen</span>
00004 <span class="comment"> * Copyright (C) 2002   Uwe Rathmann</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> * This library is free software; you can redistribute it and/or</span>
00007 <span class="comment"> * modify it under the terms of the Qwt License, Version 1.0</span>
00008 <span class="comment"> *****************************************************************************/</span>
00009 
00010 <span class="preprocessor">#include &lt;qevent.h&gt;</span>
00011 <span class="preprocessor">#include &lt;qdrawutil.h&gt;</span>
00012 <span class="preprocessor">#include &lt;qpainter.h&gt;</span>
00013 <span class="preprocessor">#include &lt;qstyle.h&gt;</span>
00014 <span class="preprocessor">#include "<a class="code" href="qwt__math_8h.html">qwt_math.h</a>"</span>
00015 <span class="preprocessor">#include "qwt_paint_buffer.h"</span>
00016 <span class="preprocessor">#include "qwt_wheel.h"</span>
00017 
00018 
<a name="l00020"></a><a class="code" href="class_qwt_wheel.html#a0">00020</a> <a class="code" href="class_qwt_wheel.html#a0">QwtWheel::QwtWheel</a>(QWidget *parent, <span class="keyword">const</span> <span class="keywordtype">char</span> *name): 
00021     <a class="code" href="class_qwt_slider_base.html">QwtSliderBase</a>(Qt::Horizontal, parent, name, 
00022     Qt::WRepaintNoErase|Qt::WResizeNoErase )
00023 {
00024     d_viewAngle = 175.0;
00025     d_totalAngle = 360.0;
00026     d_tickCnt = 10;
00027     d_intBorder = 2;
00028     d_borderWidth = 2;
00029     d_colorCnt = 30;
00030     d_wheelWidth = 20;
00031     d_allocContext = 0;
00032     d_colors = <span class="keyword">new</span> QColor[d_colorCnt];
00033     <a class="code" href="class_qwt_slider_base.html#a2">setUpdateTime</a>(50);
00034 }
00035 
<a name="l00037"></a><a class="code" href="class_qwt_wheel.html#a1">00037</a> <a class="code" href="class_qwt_wheel.html#a1">QwtWheel::~QwtWheel</a>()  
00038 {
00039     <span class="keywordflow">if</span> ( d_allocContext )
00040         QColor::destroyAllocContext( d_allocContext );
00041     <span class="keyword">delete</span>[] d_colors;
00042 }
00043 
<a name="l00045"></a><a class="code" href="class_qwt_wheel.html#b6">00045</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#b6">QwtWheel::setColorArray</a>()
00046 {
00047     <span class="keywordflow">if</span> ( !d_colors ) 
00048         <span class="keywordflow">return</span>;
00049 
00050     QColorGroup g = colorGroup();
00051 
00052     <span class="keywordflow">if</span> ( !d_colors[0].isValid() ||
00053         d_colors[0] != g.light() ||
00054         d_colors[d_colorCnt - 1] != g.dark() )
00055     {
00056         <span class="keywordflow">if</span> ( d_allocContext )
00057             QColor::destroyAllocContext( d_allocContext );
00058 
00059         d_allocContext = QColor::enterAllocContext();
00060 
00061         d_colors[0] = g.light();
00062         d_colors[d_colorCnt - 1] = g.dark();
00063 
00064         <span class="keywordtype">int</span> dh, ds, dv, lh, ls, lv;
00065         d_colors[0].rgb(&amp;lh, &amp;ls, &amp;lv);
00066         d_colors[d_colorCnt - 1].rgb(&amp;dh, &amp;ds, &amp;dv);
00067 
00068         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 1; i &lt; d_colorCnt - 1; ++i )
00069         {
00070             <span class="keyword">const</span> <span class="keywordtype">double</span> factor = double(i) / double(d_colorCnt);
00071 
00072             d_colors[i].setRgb( lh + <span class="keywordtype">int</span>( <span class="keywordtype">double</span>(dh - lh) * factor ),
00073                       ls + <span class="keywordtype">int</span>( <span class="keywordtype">double</span>(ds - ls) * factor ),
00074                       lv + <span class="keywordtype">int</span>( <span class="keywordtype">double</span>(dv - lv) * factor ));
00075         }
00076         QColor::leaveAllocContext();
00077     }
00078 }
00079 
<a name="l00088"></a><a class="code" href="class_qwt_wheel.html#a9">00088</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#a9">QwtWheel::setTickCnt</a>(<span class="keywordtype">int</span> cnt)
00089 {
00090     d_tickCnt = <a class="code" href="qwt__math_8h.html#a37">qwtLim</a>( cnt, 6, 50 );
00091     update();
00092 }
00093 
<a name="l00097"></a><a class="code" href="class_qwt_wheel.html#a7">00097</a> <span class="keywordtype">double</span> <a class="code" href="class_qwt_wheel.html#a7">QwtWheel::mass</a>()<span class="keyword"> const</span>
00098 <span class="keyword"></span>{
00099     <span class="keywordflow">return</span> <a class="code" href="class_qwt_slider_base.html#a6">QwtSliderBase::mass</a>();
00100 }
00101 
00102 
00103 
<a name="l00114"></a><a class="code" href="class_qwt_wheel.html#a11">00114</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#a11">QwtWheel::setInternalBorder</a>( <span class="keywordtype">int</span> w )
00115 {
00116     <span class="keyword">const</span> <span class="keywordtype">int</span> d = qwtMin( width(), height() ) / 3;
00117     w = qwtMin( w, d );
00118     d_intBorder = qwtMax( w, 1 );
00119     <a class="code" href="class_qwt_wheel.html#b2">layoutWheel</a>();
00120 }
00121 
<a name="l00123"></a><a class="code" href="class_qwt_wheel.html#b5">00123</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#b5">QwtWheel::drawWheelBackground</a>( QPainter *p, <span class="keyword">const</span> QRect &amp;r )
00124 {
00125     p-&gt;save();
00126 
00127     <span class="comment">//</span>
00128     <span class="comment">// initialize pens</span>
00129     <span class="comment">//</span>
00130     <span class="keyword">const</span> QColorGroup g = colorGroup();
00131 
00132     QPen lightPen;
00133     lightPen.setColor(g.light());
00134     lightPen.setWidth(d_intBorder);
00135 
00136     QPen darkPen;
00137     darkPen.setColor(g.dark());
00138     darkPen.setWidth(d_intBorder);
00139 
00140     <a class="code" href="class_qwt_wheel.html#b6">setColorArray</a>();
00141 
00142     <span class="comment">//</span>
00143     <span class="comment">// initialize auxiliary variables</span>
00144     <span class="comment">//</span>
00145 
00146     <span class="keyword">const</span> <span class="keywordtype">int</span> nFields = d_colorCnt * 13 / 10;
00147     <span class="keyword">const</span> <span class="keywordtype">int</span> hiPos = nFields - d_colorCnt + 1;
00148 
00149     <span class="keywordflow">if</span> ( <a class="code" href="class_qwt_slider_base.html#a8">orientation</a>() == Qt::Horizontal )
00150     {
00151         <span class="keyword">const</span> <span class="keywordtype">int</span> rx = r.x();
00152         <span class="keywordtype">int</span> ry = r.y() + d_intBorder;
00153         <span class="keyword">const</span> <span class="keywordtype">int</span> rh = r.height() - 2* d_intBorder;
00154         <span class="keyword">const</span> <span class="keywordtype">int</span> rw = r.width();
00155         <span class="comment">//</span>
00156         <span class="comment">//  draw shaded background</span>
00157         <span class="comment">//</span>
00158         <span class="keywordtype">int</span> x1 = rx;
00159         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; nFields; i++ )
00160         {
00161             <span class="keyword">const</span> <span class="keywordtype">int</span> x2 = rx + (rw * i) / nFields;
00162             p-&gt;fillRect(x1, ry, x2-x1 + 1 ,rh, d_colors[qwtAbs(i-hiPos)]);
00163             x1 = x2 + 1;
00164         }
00165         p-&gt;fillRect(x1, ry, rw - (x1 - rx), rh, d_colors[d_colorCnt - 1]);
00166 
00167         <span class="comment">//</span>
00168         <span class="comment">// draw internal border</span>
00169         <span class="comment">//</span>
00170         p-&gt;setPen(lightPen);
00171         ry = r.y() + d_intBorder / 2;
00172         p-&gt;drawLine(r.x(), ry, r.x() + r.width() , ry);
00173 
00174         p-&gt;setPen(darkPen);
00175         ry = r.y() + r.height() - (d_intBorder - d_intBorder / 2);
00176         p-&gt;drawLine(r.x(), ry , r.x() + r.width(), ry);
00177     }
00178     <span class="keywordflow">else</span> <span class="comment">// Qt::Vertical</span>
00179     {
00180         <span class="keywordtype">int</span> rx = r.x() + d_intBorder;
00181         <span class="keyword">const</span> <span class="keywordtype">int</span> ry = r.y();
00182         <span class="keyword">const</span> <span class="keywordtype">int</span> rh = r.height();
00183         <span class="keyword">const</span> <span class="keywordtype">int</span> rw = r.width() - 2 * d_intBorder;
00184 
00185         <span class="comment">//</span>
00186         <span class="comment">// draw shaded background</span>
00187         <span class="comment">//</span>
00188         <span class="keywordtype">int</span> y1 = ry;
00189         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 1; i &lt; nFields; i++ )
00190         {
00191             <span class="keyword">const</span> <span class="keywordtype">int</span> y2 = ry + (rh * i) / nFields;
00192             p-&gt;fillRect(rx, y1, rw, y2-y1 + 1, d_colors[qwtAbs(i-hiPos)]);
00193             y1 = y2 + 1;
00194         }
00195         p-&gt;fillRect(rx, y1, rw, rh - (y1 - ry), d_colors[d_colorCnt - 1]);
00196 
00197         <span class="comment">//</span>
00198         <span class="comment">//  draw internal borders</span>
00199         <span class="comment">//</span>
00200         p-&gt;setPen(lightPen);
00201         rx = r.x() + d_intBorder / 2;
00202         p-&gt;drawLine(rx, r.y(), rx, r.y() + r.height());
00203 
00204         p-&gt;setPen(darkPen);
00205         rx = r.x() + r.width() - (d_intBorder - d_intBorder / 2);
00206         p-&gt;drawLine(rx, r.y(), rx , r.y() + r.height());
00207     }
00208 
00209     p-&gt;restore();
00210 }
00211 
00212 
<a name="l00224"></a><a class="code" href="class_qwt_wheel.html#a8">00224</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#a8">QwtWheel::setTotalAngle</a>(<span class="keywordtype">double</span> angle)
00225 {
00226     d_totalAngle = <a class="code" href="qwt__math_8h.html#a37">qwtLim</a>( angle, 10.0, 3600.0 );
00227     update();
00228 }
00229 
<a name="l00237"></a><a class="code" href="class_qwt_wheel.html#a2">00237</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#a2">QwtWheel::setOrientation</a>(Qt::Orientation o)
00238 {
00239     <span class="keywordflow">if</span> ( <a class="code" href="class_qwt_slider_base.html#a8">orientation</a>() != o )
00240     {
00241         <a class="code" href="class_qwt_slider_base.html#a7">QwtSliderBase::setOrientation</a>(o);
00242         <a class="code" href="class_qwt_wheel.html#b2">layoutWheel</a>();
00243     }
00244 }
00245 
<a name="l00254"></a><a class="code" href="class_qwt_wheel.html#a10">00254</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#a10">QwtWheel::setViewAngle</a>(<span class="keywordtype">double</span> angle)
00255 {
00256     d_viewAngle = <a class="code" href="qwt__math_8h.html#a37">qwtLim</a>( angle, 10.0, 175.0 );
00257     update();
00258 }
00259 
<a name="l00265"></a><a class="code" href="class_qwt_wheel.html#b4">00265</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#b4">QwtWheel::drawWheel</a>( QPainter *p, <span class="keyword">const</span> QRect &amp;r )
00266 {
00267     <span class="keyword">const</span> <span class="keywordtype">double</span> sign = (<a class="code" href="class_qwt_dbl_range.html#a12">minValue</a>() &lt; <a class="code" href="class_qwt_dbl_range.html#a11">maxValue</a>()) ? 1.0 : -1.0;
00268     <span class="keywordtype">double</span> cnvFactor = qwtAbs(d_totalAngle / (<a class="code" href="class_qwt_dbl_range.html#a11">maxValue</a>() - <a class="code" href="class_qwt_dbl_range.html#a12">minValue</a>()));
00269     <span class="keyword">const</span> <span class="keywordtype">double</span> halfIntv = 0.5 * d_viewAngle / cnvFactor;
00270     <span class="keyword">const</span> <span class="keywordtype">double</span> loValue = <a class="code" href="class_qwt_dbl_range.html#a6">value</a>() - halfIntv;
00271     <span class="keyword">const</span> <span class="keywordtype">double</span> hiValue = <a class="code" href="class_qwt_dbl_range.html#a6">value</a>() + halfIntv;
00272     <span class="keyword">const</span> <span class="keywordtype">double</span> tickWidth = 360.0 / double(d_tickCnt) / cnvFactor;
00273     <span class="keyword">const</span> <span class="keywordtype">double</span> sinArc = sin(d_viewAngle * M_PI / 360.0);
00274     cnvFactor *= M_PI / 180.0;
00275 
00276     <span class="comment">//</span>
00277     <span class="comment">// draw background gradient</span>
00278     <span class="comment">//</span>
00279     <a class="code" href="class_qwt_wheel.html#b5">drawWheelBackground</a>( p, r );
00280 
00281     <span class="comment">//</span>
00282     <span class="comment">// draw grooves</span>
00283     <span class="comment">//</span>
00284     <span class="keywordflow">if</span> ( <a class="code" href="class_qwt_slider_base.html#a8">orientation</a>() == Qt::Horizontal )
00285     {
00286         <span class="keyword">const</span> <span class="keywordtype">double</span> halfSize = double(r.width()) * 0.5;
00287 
00288         <span class="keywordtype">int</span> l1 = r.y() + d_intBorder;
00289         <span class="keywordtype">int</span> l2 = r.y() + r.height() - d_intBorder - 1;
00290 
00291         <span class="comment">// draw one point over the border if border &gt; 1</span>
00292         <span class="keywordflow">if</span> ( d_intBorder &gt; 1 )
00293         {
00294             l1 --;
00295             l2 ++;
00296         }
00297 
00298         <span class="keyword">const</span> <span class="keywordtype">int</span> maxpos = r.x() + r.width() - 2;
00299         <span class="keyword">const</span> <span class="keywordtype">int</span> minpos = r.x() + 2;
00300 
00301         <span class="comment">//</span>
00302         <span class="comment">// draw tick marks</span>
00303         <span class="comment">//</span>
00304         <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> tickValue = ceil(loValue / tickWidth) * tickWidth;
00305             tickValue &lt; hiValue; tickValue += tickWidth )
00306         {
00307             <span class="comment">//</span>
00308             <span class="comment">//  calculate position</span>
00309             <span class="comment">//</span>
00310             <span class="keyword">const</span> <span class="keywordtype">int</span> tickPos = r.x() + r.width()
00311                 - int( halfSize
00312                     * (sinArc + sign *  sin((tickValue - <a class="code" href="class_qwt_dbl_range.html#a6">value</a>()) * cnvFactor))
00313                     / sinArc);
00314             <span class="comment">//</span>
00315             <span class="comment">// draw vertical line</span>
00316             <span class="comment">//</span>
00317             <span class="keywordflow">if</span> ( (tickPos &lt;= maxpos) &amp;&amp; (tickPos &gt; minpos) )
00318             {
00319                 p-&gt;setPen(colorGroup().dark());
00320                 p-&gt;drawLine(tickPos -1 , l1, tickPos - 1,  l2 );  
00321                 p-&gt;setPen(colorGroup().light());
00322                 p-&gt;drawLine(tickPos, l1, tickPos, l2);  
00323             }
00324         }
00325     }
00326     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="class_qwt_slider_base.html#a8">orientation</a>() == Qt::Vertical )
00327     {
00328         <span class="keyword">const</span> <span class="keywordtype">double</span> halfSize = double(r.height()) * 0.5;
00329 
00330         <span class="keywordtype">int</span> l1 = r.x() + d_intBorder;
00331         <span class="keywordtype">int</span> l2 = r.x() + r.width() - d_intBorder - 1;
00332 
00333         <span class="keywordflow">if</span> ( d_intBorder &gt; 1 )
00334         {
00335             l1--;
00336             l2++;
00337         }
00338 
00339         <span class="keyword">const</span> <span class="keywordtype">int</span> maxpos = r.y() + r.height() - 2;
00340         <span class="keyword">const</span> <span class="keywordtype">int</span> minpos = r.y() + 2;
00341 
00342         <span class="comment">//</span>
00343         <span class="comment">// draw tick marks</span>
00344         <span class="comment">//</span>
00345         <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> tickValue = ceil(loValue / tickWidth) * tickWidth;
00346             tickValue &lt; hiValue; tickValue += tickWidth )
00347         {
00348 
00349             <span class="comment">//</span>
00350             <span class="comment">// calculate position</span>
00351             <span class="comment">//</span>
00352             <span class="keyword">const</span> <span class="keywordtype">int</span> tickPos = r.y() + int( halfSize *
00353                 (sinArc + sign * sin((tickValue - <a class="code" href="class_qwt_dbl_range.html#a6">value</a>()) * cnvFactor))
00354                 / sinArc);
00355 
00356             <span class="comment">//</span>
00357             <span class="comment">//  draw horizontal line</span>
00358             <span class="comment">//</span>
00359             <span class="keywordflow">if</span> ( (tickPos &lt;= maxpos) &amp;&amp; (tickPos &gt; minpos) )
00360             {
00361                 p-&gt;setPen(colorGroup().dark());
00362                 p-&gt;drawLine(l1, tickPos - 1 ,l2, tickPos - 1);  
00363                 p-&gt;setPen(colorGroup().light());
00364                 p-&gt;drawLine(l1, tickPos, l2, tickPos);  
00365             }
00366         }
00367     }
00368 }
00369 
00370 
<a name="l00372"></a><a class="code" href="class_qwt_wheel.html#b9">00372</a> <span class="keywordtype">double</span> <a class="code" href="class_qwt_wheel.html#b9">QwtWheel::getValue</a>( <span class="keyword">const</span> QPoint &amp;p )
00373 {
00374     <span class="comment">// The reference position is arbitrary, but the</span>
00375     <span class="comment">// sign of the offset is important</span>
00376     <span class="keywordtype">int</span> w, dx;
00377     <span class="keywordflow">if</span> ( <a class="code" href="class_qwt_slider_base.html#a8">orientation</a>() == Qt::Vertical )
00378     {
00379         w = d_sliderRect.height();
00380         dx = d_sliderRect.y() - p.y();
00381     }
00382     <span class="keywordflow">else</span>
00383     {
00384         w = d_sliderRect.width();
00385         dx = p.x() - d_sliderRect.x();
00386     }
00387 
00388     <span class="comment">// w pixels is an arc of viewAngle degrees,</span>
00389     <span class="comment">// so we convert change in pixels to change in angle</span>
00390     <span class="keyword">const</span> <span class="keywordtype">double</span> ang = dx * d_viewAngle / w;
00391 
00392     <span class="comment">// value range maps to totalAngle degrees,</span>
00393     <span class="comment">// so convert the change in angle to a change in value</span>
00394     <span class="keyword">const</span> <span class="keywordtype">double</span> val = ang * ( <a class="code" href="class_qwt_dbl_range.html#a11">maxValue</a>() - <a class="code" href="class_qwt_dbl_range.html#a12">minValue</a>() ) / d_totalAngle;
00395 
00396     <span class="comment">// Note, range clamping and rasterizing to step is automatically</span>
00397     <span class="comment">// handled by QwtSliderBase, so we simply return the change in value</span>
00398     <span class="keywordflow">return</span> val;
00399 }
00400 
<a name="l00402"></a><a class="code" href="class_qwt_wheel.html#b0">00402</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#b0">QwtWheel::resizeEvent</a>(QResizeEvent *)
00403 {
00404     <a class="code" href="class_qwt_wheel.html#b2">layoutWheel</a>( FALSE );
00405 }
00406 
00408 <span class="comment">//  the current rect and fonts.</span>
00409 <span class="comment">//  \param update_geometry  notify the layout system and call update</span>
00410 <span class="comment">//         to redraw the scale</span>
<a name="l00411"></a><a class="code" href="class_qwt_wheel.html#b2">00411</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#b2">QwtWheel::layoutWheel</a>( <span class="keywordtype">bool</span> update_geometry )
00412 {
00413     <span class="keyword">const</span> QRect r = this-&gt;rect();
00414     d_sliderRect.setRect(r.x() + d_borderWidth, r.y() + d_borderWidth,
00415         r.width() - 2*d_borderWidth, r.height() - 2*d_borderWidth);
00416 
00417     <span class="keywordflow">if</span> ( update_geometry )
00418     {
00419         updateGeometry();
00420         update();
00421     }
00422 }
00423 
<a name="l00425"></a><a class="code" href="class_qwt_wheel.html#b1">00425</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#b1">QwtWheel::paintEvent</a>(QPaintEvent *e)
00426 {
00427     <span class="comment">// Use double-buffering</span>
00428     <span class="keyword">const</span> QRect &amp;ur = e-&gt;rect();
00429     <span class="keywordflow">if</span> ( ur.isValid() )
00430     {
00431         <a class="code" href="class_qwt_paint_buffer.html">QwtPaintBuffer</a> paintBuffer(<span class="keyword">this</span>, ur);
00432         <a class="code" href="class_qwt_wheel.html#b3">draw</a>(paintBuffer.<a class="code" href="class_qwt_paint_buffer.html#a5">painter</a>(), ur);
00433     }
00434 }
00435 
<a name="l00437"></a><a class="code" href="class_qwt_wheel.html#b3">00437</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#b3">QwtWheel::draw</a>(QPainter *painter, <span class="keyword">const</span> QRect&amp;)
00438 {
00439     QColorGroup cg = colorGroup();
00440 
00441     <span class="comment">// Rather than maintain a separate color group</span>
00442     <span class="comment">// for the outer frame, use our parent's cg</span>
00443     QWidget *parent = parentWidget();
00444     <span class="keywordflow">if</span> ( parent )
00445         cg = parent-&gt;colorGroup();
00446 
00447     qDrawShadePanel( painter, rect().x(), rect().y(),
00448         rect().width(), rect().height(),
00449         cg, TRUE, d_borderWidth );
00450 
00451     <a class="code" href="class_qwt_wheel.html#b4">drawWheel</a>( painter, d_sliderRect );
00452 
00453     <span class="keywordflow">if</span> ( hasFocus() )
00454     {
00455         QRect r = rect();
00456     
00457 <span class="preprocessor">#if QT_VERSION &lt; 300</span>
00458 <span class="preprocessor"></span>        style().drawFocusRect(painter, r, colorGroup());
00459 <span class="preprocessor">#else</span>
00460 <span class="preprocessor"></span>        style().drawPrimitive(QStyle::PE_FocusRect, painter,
00461             r, colorGroup());
00462 <span class="preprocessor">#endif</span>
00463 <span class="preprocessor"></span>    }
00464 }
00465 
<a name="l00467"></a><a class="code" href="class_qwt_wheel.html#b7">00467</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#b7">QwtWheel::valueChange</a>()
00468 {
00469     <a class="code" href="class_qwt_slider_base.html#b1">QwtSliderBase::valueChange</a>();
00470     update();
00471 }
00472 
00473 
<a name="l00481"></a><a class="code" href="class_qwt_wheel.html#b10">00481</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#b10">QwtWheel::getScrollMode</a>( <span class="keyword">const</span> QPoint &amp;p, <span class="keywordtype">int</span> &amp;scrollMode, <span class="keywordtype">int</span> &amp;direction)
00482 {
00483     <span class="keywordflow">if</span> ( d_sliderRect.contains(p) )
00484         scrollMode = ScrMouse;
00485     <span class="keywordflow">else</span>
00486         scrollMode = ScrNone;
00487 
00488     direction = 0;
00489 }
00490 
<a name="l00497"></a><a class="code" href="class_qwt_wheel.html#a12">00497</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#a12">QwtWheel::setMass</a>(<span class="keywordtype">double</span> val)
00498 {
00499     <a class="code" href="class_qwt_slider_base.html#a5">QwtSliderBase::setMass</a>(val);
00500 }
00501 
<a name="l00509"></a><a class="code" href="class_qwt_wheel.html#a13">00509</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#a13">QwtWheel::setWheelWidth</a>(<span class="keywordtype">int</span> w)
00510 {
00511     d_wheelWidth = w;
00512     <a class="code" href="class_qwt_wheel.html#b2">layoutWheel</a>();
00513 }
00514 
<a name="l00520"></a><a class="code" href="class_qwt_wheel.html#a16">00520</a> QSizePolicy <a class="code" href="class_qwt_wheel.html#a16">QwtWheel::sizePolicy</a>()<span class="keyword"> const</span>
00521 <span class="keyword"></span>{
00522     QSizePolicy sp;
00523     <span class="keywordflow">if</span> ( <a class="code" href="class_qwt_slider_base.html#a8">orientation</a>() == Qt::Horizontal )
00524     {
00525         sp.setHorData( QSizePolicy::Preferred );
00526         sp.setVerData( QSizePolicy::Fixed );
00527     }
00528     <span class="keywordflow">else</span>
00529     {
00530         sp.setHorData( QSizePolicy::Fixed );
00531         sp.setVerData( QSizePolicy::Preferred );
00532     }
00533     <span class="keywordflow">return</span> sp;
00534 }
00535 
<a name="l00539"></a><a class="code" href="class_qwt_wheel.html#a14">00539</a> QSize <a class="code" href="class_qwt_wheel.html#a14">QwtWheel::sizeHint</a>()<span class="keyword"> const</span>
00540 <span class="keyword"></span>{
00541     <span class="keywordflow">return</span> <a class="code" href="class_qwt_wheel.html#a15">minimumSizeHint</a>();
00542 }
00543 
<a name="l00548"></a><a class="code" href="class_qwt_wheel.html#a15">00548</a> QSize <a class="code" href="class_qwt_wheel.html#a15">QwtWheel::minimumSizeHint</a>()<span class="keyword"> const</span>
00549 <span class="keyword"></span>{
00550     QSize sz( 3*d_wheelWidth + 2*d_borderWidth,
00551     d_wheelWidth + 2*d_borderWidth );
00552     <span class="keywordflow">if</span> ( <a class="code" href="class_qwt_slider_base.html#a8">orientation</a>() != Qt::Horizontal )
00553         sz.transpose();
00554     <span class="keywordflow">return</span> sz;
00555 }
00556 
<a name="l00560"></a><a class="code" href="class_qwt_wheel.html#b8">00560</a> <span class="keywordtype">void</span> <a class="code" href="class_qwt_wheel.html#b8">QwtWheel::paletteChange</a>( <span class="keyword">const</span> QPalette&amp; )
00561 {
00562     update();
00563 }
00564 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Nov 20 13:42:38 2004 for Qwt User's Guide by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
